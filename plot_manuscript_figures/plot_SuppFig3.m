%% Analyze error distribution
[~,data_dir] = addPaths_dnn_neuron_stim;
layer_set_num = 1; 
layer_nums = 2:4;
data_fold = 'summary_data'; % run plot_Fig3_panels first to generate summary_data files
Nsample = 9;
width = 0.4;  % 0.2 def
data_mode = 1; % 1 - plot all threshold errors at all positions (panel A)
               % 2 - plot median of all threshold errors at each position (panel B)
               % 3 - plot error of median thresholds at each position
thresh_quant_cutoff = 0; % include thresholds below this quantile
per_err_cutoff = 5; % for printing % points with < cutoff % error
y_mode = 'loglinlog'; 
outlier_size=1.5; % 1.5 for calculating outliers => quantile +/- IQR*outlier_size
linlimit = 1; % for loglinlog plot
y_lim = [-100,100]; 
font_size = 20; 
font_name = 'Helvetica';
fig_units = 'centimeters';
fig_size = [21 10]*2;
fig_fold = 'error_dist_vsU_figs';
% cols = [0.5961 0.3059 0.6392;0.5 1 0.5;0 1 1];
cols = [1 0 1;0 1 0]; 
save_fig = 1;
layer_names = {'L2/3 PCs','L4 LBCs','L5 PCs'};
x_data_all = [2*(1:length(layer_names))-1;2*(1:length(layer_names))]';
% x_data_all = [(1:4:4*length(layer_names))-width*2;(1:4:4*length(layer_names))+width*2]';
% Uses saved threshold/error data generated by
% plot_all_thresh_layer_figs & plotCNNThreshLayer_ernie_test_L2_Fig.m...
%% Load data
data_all = cell(length(layer_nums),1);
data_allU = cell(length(layer_nums),1);
for i = 1:length(layer_nums)
    data_all{i} = load(fullfile(data_fold,sprintf('L%g_test.mat',layer_nums(i))));    
    data_allU{i} = load(fullfile(data_fold,sprintf('L%g_test_unif.mat',layer_nums(i))));    
end
layers = loadLayers(layer_set_num);
MeshROI = loadMeshROI(layers);
fprintf('loaded data\n')
%% Plot all points more superficial than depth_cutoff
fprintf('******\n')
fig = figure; 
fig.Units = fig_units; 
fig.Position(3:4) = fig_size; 
for j = 1:length(layer_nums)
    layer_num = layer_nums(j); 
    per_errs = data_all{layer_num == layer_nums}.plot_errs; 
    nrn_data = data_all{layer_num == layer_nums}.nrn_data;
    dnn_data = data_all{layer_num == layer_nums}.dnn_data;
    nrn_data_mat = cell2mat(nrn_data); 
    if data_mode == 2
        nrn_data_mat = median(nrn_data_mat,2);        
    end
    dnn_data_mat = cell2mat(dnn_data);
    per_errs_mat = cell2mat(per_errs);
    quants = quantile(per_errs_mat(:),[0.01 0.99]);    
    if data_mode == 3 % per error of median thresholds at each position
        % cnn
        per_errs_mat = 100*(median(dnn_data_mat,2) - median(nrn_data_mat,2))./median(nrn_data_mat,2);
        % unif E
        threshEs_mat = cell2mat(data_allU{layer_num== layer_nums}.threshEs); 
        threshEsM_mat = cell2mat(data_allU{layer_num== layer_nums}.threshEsM); 
        per_errsU_mat = 100*(median(threshEsM_mat,2) - median(threshEs_mat,2))./median(threshEs_mat,2);        
    else
        per_errsU = data_allU{layer_num== layer_nums}.plot_errs; 
        per_errsU_mat = cell2mat(per_errsU);        
    end    
                 
    % Plot    
    % filter based on threshold
    quantj = quantile(nrn_data_mat(:),thresh_quant_cutoff);
    if thresh_quant_cutoff > 0 && thresh_quant_cutoff < 1  
        if data_mode == 1
            per_errs_mat(nrn_data_mat > quantj) = nan;
            per_errsU_mat(nrn_data_mat > quantj) = nan;
        elseif data_mode == 2
            per_errs_mat = median(per_errs_mat,2,'omitnan');
            perr_errsU_mat = median(per_errsU_mat,2,'omitnan'); 
            per_errs_mat(nrn_data_mat > quantj) = nan;
            per_errsU_mat(nrn_data_mat > quantj) = nan;
        end
        fprintf('Excluding %g/%g points (%g %%) > %g quantile (%.2f A/us)\n',...
            sum(nrn_data_mat > quantj,'all'),numel(nrn_data_mat),...
            100*sum(nrn_data_mat > quantj,'all')/numel(nrn_data_mat),thresh_quant_cutoff,quantj);
    end
    if data_mode == 1
        errsj = per_errs_mat(:);            
        errsjU = per_errsU_mat(:); 
    elseif data_mode == 2
        errsj = median(per_errs_mat,2,'omitnan'); 
        errsjU = median(per_errsU_mat,2,'omitnan');                        
    elseif data_mode == 3
        errsj = per_errs_mat;  % already took median above
        errsjU = per_errsU_mat;         
    end
    x_data = x_data_all(j,:); 
    y_data = [errsj,errsjU];
    for i = 1:length(x_data)
        if strcmp(y_mode,'log')
            hV = Violin(log10(abs(y_data(:,i))),x_data(i),'ViolinColor',cols(i,:),'Width',width,...
                   'BoxColor',cols(i,:),'BoxWidth',width,...
                   'ShowData',true,'ShowNotches',false); hold on; % abs(median(errsi,2))
        elseif strcmp(y_mode,'loglinlog')
            hV = Violin(y_data(:,i),x_data(i),'ViolinColor',cols(i,:),'Width',width,...
                   'BoxColor',cols(i,:),'BoxWidth',width,...
                   'ShowData',true,'ShowNotches',false); hold on; % abs(median(errsi,2))
            apply_loglinlog_Violin(hV,linlimit); 
        else
            Violin(abs(y_data(:,i)),x_data(i),'ViolinColor',cols(i,:),'Width',width,...
                   'BoxColor',cols(i,:),'BoxWidth',width,...
                   'ShowData',true,'ShowNotches',false); hold on; % abs(median(errsi,2))
        end    
    end
    num_pts = sum(~isnan(y_data),1);
    quartiles = quantile(y_data, [0.25, 0.5, 0.75]);         
    IQR = quartiles(3,:) - quartiles(1,:);
    lowhisker = quartiles(1,:) - outlier_size*IQR;    
    hiwhisker = quartiles(3,:) + outlier_size*IQR;
    outlier_inds = y_data > hiwhisker | y_data < lowhisker;    
    num_outliers = sum(outlier_inds,1);    
    % cnn
    fprintf('L%g, cnn: range of errs (%.2f, %.2f), mean abs = %.2f, med abs = %.2f\n',...
            layer_nums(j),min(y_data(:,1),[],'omitnan'),max(y_data(:,1),[],'omitnan'),...
            mean(abs(y_data(:,1)),'omitnan'),median(abs(y_data(:,1)),'omitnan'))
    if data_mode == 2 % for medians only
        fprintf(' cnn: %g %% below %g %% error\n',100*sum(abs(errsj) < per_err_cutoff)/numel(errsj),per_err_cutoff)
        fprintf(' unifE: %g %% below %g %% error\n',100*sum(abs(errsjU) < per_err_cutoff)/numel(errsjU),per_err_cutoff)
    end    
    % unifE
    fprintf('L%g, unif: range of errs (%f, %f), mean abs = %.2f, med abs = %.2f\n',...
        layer_nums(j),min(y_data(:,2),[],'omitnan'),max(y_data(:,2),[],'omitnan'),...
        mean(abs(y_data(:,2)),'omitnan'),median(abs(y_data(:,2)),'omitnan'))    
        
    
end
box off; 
ax = gca;
ax.XTick = mean(x_data_all,2);
ax.XTickLabel = layer_names; 
if strcmp(y_mode,'log')
    ax.YTickLabel = arrayfun(@(x) sprintf('10^{%g}',x),ax.YTick,'UniformOutput',0);
elseif strcmp(y_mode,'loglinlog')
    set_ytick_loglinlog(y_lim,y_lim(2),linlimit,ax); 
end
if data_mode == 1 || data_mode == 3
    if strcmp(y_mode,'log')
        ylabel('Abs. percent error (%)');
    else
        ylabel('Percent error (%)'); 
    end
elseif data_mode == 2
    if strcmp(y_mode,'log')
        ylabel('Median abs. percent error (%)');
    else
        ylabel('Median percent error (%)');
    end
end
ax.FontSize = font_size; 
ax.FontName = font_name;    
ax.XColor = 'k';
ax.YColor = 'k';
if save_fig
    fig_namej = sprintf('per_errs_%g_y%s_q%g',data_mode,y_mode,thresh_quant_cutoff);
    printFig(fig,fig_fold,fig_namej);        
end
 